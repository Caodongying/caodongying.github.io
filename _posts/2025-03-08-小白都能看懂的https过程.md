---
title: "小白都能看懂的https过程"
date: 2025-03-08
categories: https
---

当你浏览网页的时候，你或许会留意到大部分网页的地址都以https开头。而当你访问那些以http（没有s）作为前缀的网站的时候，诸如Chrome这样的浏览器会提示你这是“不安全的连接”。你也许会感到好奇：

为什么连接会有安全和不安全之分呢？什么是https？为什么以https://开头的网站要比以http://开头的网站安全呢？浏览那些http网站存在哪些安全隐患？我该如何将我的网站由http“升级”为https呢？

HTTPS协议的全称是HyperText Transfer Protocol Secure，超文本传输协议安全。HTTPS协议是传输层HTTP协议的安全版本，因为其在HTTP协议的基础上添加了TLS/SSL加密层。与https相关的概念和话题有很多，你也许听过以下这些词：对称加密，非对称加密，CA(Certificate Authority)，证书验证，申请证书，公钥私钥......本文将由浅入深、抽丝剥茧地为你讲解https协议。

# 场景描述
假设你作为client（用户），想要访问一个网站，并且需要发送一些你不想被别人知道的数据，比如你的出生日期、银行卡账号等。为了表述方便，我们假设要访问的网站叫做www.caodongying.com。如果www.caodongying.com采用的是http协议，那么你在浏览网页、在某一刻提交自己信息的时候，数据是以明文的方式被传输的。也就是说如果黑客劫持了你和www.caodongying.com之间的连接，那么他就可以直接看到你所发送的消息，也可以看到www.caodongying.com返回给你的数据。

这会带来什么问题呢？有三点：
1. 信息泄露（窃听风险）。你向www.caodongying.com提交了自己的生日和银行卡账号，但是黑客劫持了连接并且知道了这些信息。
2. 数据篡改（篡改风险）。你访问www.caodongying.com时是想纯粹地阅读一些博客，但是黑客劫持了www.caodongying.com返回给你的博客界面，并且修改了脚本，在里面插入了广告。如此一来，你的阅读体验就大大下降。
3. 身份冒充。黑客可以冒充www.caodongying.com，你希望阅读一篇关于https的技术博客，但是黑客在冒充了这个网站后，返回给你一些其他消极的内容。

而如果www.caodongying.com采用https协议来传输数据，你的信息就会经过加密然后被传输。假设你原本的数据是”我的银行卡账号是12431"，加密后的结果就是"hjw#7428"，即使黑客劫持了你的连接也只能看到一串意义不明的加密码，无法知道真正的内容是什么。至于https是如何防止网站服务器返回的内容被篡改、防止网站本身被冒充的，我们将在下文继续介绍。

# 需求分析
现在我们知道了使用http协议进行数据传输会带来的问题，那么我们就可以知道作为解决方案的https协议身负的重任。我们从软件需求的角度来罗列一下https协议应该实现哪些需求：

1. 数据在传输前要经过加密
2. 网站不可以被冒充
3. 数据在传输过程中不可以被更改

# HTTPS协议内容
在https协议下，网站配置和用户访问网站的过程遵循如下流程：
1. 网站向CA申请证书，并在获取证书后将证书保存在网站服务器（server）中。CA可以保证客户端浏览器（client）收到的公钥的确是其要访问的网页发送的，也就是说，“我想访问百度界面，并且我收到的公钥的确是百度发的”。（这里是第一次非对称加密，CA利用私钥进行签名）
2. 客户端浏览器请求访问网站
3. 网站将自己的证书（包含网站公钥）发送给浏览器
4. 浏览器验证证书是否合法（这里依然是第一次非对称加密，浏览器利用本地根证书中保存的CA的公钥，对证书进行解密）
5. 如果证书合法，浏览器和网站交换用于之后对称加密消息的密钥（旧的方法是用RSA算法，利用网站的公钥对浏览器生成的密钥进行加密；现在采纳的办法是浏览器和网站双方利用ECDHE算法交换密钥。）
6. 浏览器和网站利用这个密钥进行加密传输（对称加密，提高速率）

如果将上述步骤进行概括，那么https协议可以分为三个步骤：
1. 网站向CA请求证书
2. 客户端和网站服务器进行tls/ssl握手（第2-5步）
3. 客户端和网站利用对称加密进行数据传输

让我们来看一看这三个步骤的具体过程。

## 网站向CA请求证书

网站www.caodongying.com向CA申请证书。这是整个https协议成立的第一步。只有网站已经从正规的CA那里获取到了证书，客户端才可以安全地访问网站。从下面这张图，我们可以直观地显示网站向证书颁发机构CA请求数字证书、CA向网站颁发证书的过程。

![server_request_certificate](/assets/images/https/CA证书泳道.png)


在这个过程中，有几个值得注意的点：
- 为什么需要摘要呢？其实如果直接对证书明文进行签名，理论上来说也是可以的。但是非对称加密很复杂，耗时间，对明文进行摘要运算后可以缩减需要加密的内容长度，提高加密解密的效率。
- 证书签名请求（CSR）摘要的生成是由证书颁发机构完成的，而不是网站服务器本身。这个摘要会在被CA签名后，作为证书的一部分被发送给服务器。那么使用CA私钥签名的摘要有什么用呢？答案就是浏览器可以使用这个摘要来确认自己收到的网页的公钥是否是真的。所谓摘要（digest），其实就是运用诸如SHA256一类的哈希算法，把内容很长的CSR转化成一个固定长度的字符串。一旦原始内容发生改变，经过SHA256编码后得到的内容也一定发生改变。并且，SHA256算法是不可逆的，没有办法从算法编码的结果推算原始内容。
- 你可能会想，为什么需要对摘要签名呢？首先我们知道，在非对称加密中，“用公钥加密，只能用私钥解密”，“用私钥签名，只能用公钥解密”。这里要注意，当我们谈及“私钥加密“的时候，实际上是利用私钥进行签名（signature）。如果在生成摘要后不对齐进行任何”加密“，摘要就会以明文形式出现在证书中并在网络上”裸奔“。黑客如果截取到这不安全的证书，大可以对证书内的公钥进行修改后，重新为假证书生成摘要。这样，客户端浏览器在接收到证书的时候，即使可以对主体内容和公钥再次生成摘要，也无法验证证书是否合法。（如果看得一头雾水，没关系，等之后看到客户端浏览器是如何验证证书的时候你就懂了）。所以，概括来讲，为CSR生成摘要，是为了防止证书被黑客篡改，尤其是其中的网站公钥。
- CA对证书进行私钥签名，那么公钥保存在哪里呢？不要着急，后文会讲，这里可以提前告诉你，CA的公钥是预安装在操作系统或浏览器中的，所以，要购买正版软件系统啊。
- 网站向CA发送的CSR中会包含诸如邮件、电话号码之类的隐私信息。而在CA办法的证书中，这些信息并不包含在内。

## tls/ssl握手
为了了解tls/ssl握手的具体过程，最直观的办法当然是用Wireshark抓包看一下。但对于不清楚握手的基本流程的人来说，直接抓包看传输内容会带来更多的困惑。因此，在查看实际的包之前，让我们先了解tls/ssl握手流程中主要完成的两件事情：验证网站证书，以及让浏览器和网站双方都获得对称加密的密钥。在前文中，我们已经提到了这个过程中的步骤：

1. 客户端浏览器请求访问网站
2. 网站将自己的证书（包含网站公钥）发送给浏览器
3. 浏览器验证证书是否合法（这里依然是第一次非对称加密，浏览器利用本地根证书中保存的CA的公钥，对证书进行解密）
4. 如果证书合法，浏览器和网站交换用于之后对称加密消息的密钥（旧的方法是用RSA算法，利用网站的公钥对浏览器生成的密钥进行加密；现在常见的办法是浏览器和网站双方利用ECDHE算法交换密钥。）

### 验证网站证书
当网站想要访问网站www.caodongying.com时，网站会将自己的证书发送给浏览器。证书内容如下图所示：

![CA_Certificate](/assets/images/https/CA证书.png)

客户端浏览器在收到证书后，会使用证书中所定义的摘要算法（Signature Hash Algorithm），对证书的部分内容（网站公钥，主体信息等）再次生成摘要A。还记得我们在前文所说的CA会对证书摘要进行签名吗？没错，此时摘要的签名就要派上用场了。浏览器会用预先安装在好的CA私钥，对摘要签名进行解密，得到在CA中生成的摘要B。只要比较摘要A和摘要B是否相同，就可以知道证书在传输过程中有没有被黑客恶意篡改或者冒充了。

也就是说，CA对证书进行签名，可以使浏览器进行证书验证。黑客如果篡改证书中的信息，比如将公钥替换成自己的假公钥来进行冒充，那么浏览器所生成的摘要就会与证书携带的摘要不相同。别忘了，只有相同的内容才会有相同的摘要值。你或许会想，如果黑客既替换公钥又重新生成摘要、用自己的假私钥来对摘要签名呢？这也是行不通的，因为你的浏览器会发现无法用预先安装的CA公钥来对摘要签名进行解密（在非对称加密中，只有互为一对的公私密钥才可以互相加密解密），也就知道了证书不合法。当然，如果你的浏览器里预安装了黑客网站的公钥，也就主动信任了黑客网站，所以说要使用正版系统和正版软件。

我们可以将证书验证流程简化为下面这张图：

![certificate_validation](/assets/images/https/客户端验证证书.png)

### 准备对称加密密钥
在证书验证通过后，客户端浏览器和网站服务器会协商出一个用于对称加密的密钥，然后用此密钥进行后续的信息传输。使用对称加密而不是非对称加密来进行信息传输，主要是因为非对称加密的运算量大，速度慢。因此，在tls/ssl握手中，是使用非对称加密协商出密钥，然后用此密钥进行对称加密的消息传输。

这个协商的过程涉及较多的算法原理和设计决定，在本节中，我们只涉及最关键核心的部分。

在浏览器和网站的交互中，直接用于对数据加密的密钥叫做会话秘钥（session secret）。既然是对称加密，客户端浏览器和网站服务器都需要持有同一个session secret。这个session secret并不是由客户端直接生成后，发送给网站服务器，也不是由网站服务器直接生成后发给浏览器的。实际上，session secret由浏览器和网站各自生成，并且数值一样。那么这个session secret是如何生成的呢？请记住这句话：“分三级生成，基于客户端和服务器的两个随机数，用PRF函数生成”。在tls/ssl握手之初，客户端会生成一个随机数Client Random并以明文形式发送给网站服务器，网站服务器也会生成一个随机数Server Random并将其明文发送给客户端。这样一来，客户端和服务器就都拥有了这两个Random随机数。

session secret是由Client Random, Server Random和一个叫做master secret的主密钥，经过一个叫PRF的伪随机数生成函数，计算得到的。这个master secret也是用PRF函数生成的，只不过函数的输入值是Client Random, Server Random和一个叫做pre-master secret的预主密钥共同生成的。从下面这张图里，你可以看到简化后的session secret生成结构：以pre-master secret作为第一级，经过master secret的第二级生成，最终得到master secret。

![session_secret_generation](/assets/images/https/sessionsecret生成过程.png)

这里插个题外话，什么是PRF函数？

> PRF函数是一种伪随机数生成函数，在密码学中常用于密钥派生。一个PRF函数常记作PRF(k,x)→y，其中：
> - **k**：密钥（秘密输入），用于控制 PRF 的行为。
> - **x**：输入（公开），可以是任意长度的比特串或数值。
> - **y**：输出（伪随机值），通常为固定长度的比特串。
>
> 在tls/ssl握手中，PRF用于生成master secret和session secret。在使用PRF生成master secret的时候，k就是pre-master，而x是客户端生成的随机数和服务器生成的随机数。在用PRF生成session secret的时候，k是master secret，而x是客户端生成的随机数和服务器生成的随机数。公式表达如下：
> - 函数定义：PRF (secret,label,seed)
> - Master Secret = PRF( Pre-Master Secret, "mastersecret", Client Random + Server Random)
> - Session = PRF( Master Secret, "sessionsecret", Client Random + Server Random)

从中我们可以看到，session secret的生成在本质上是依赖于pre-master secret。pre-master secret要么由客户端生成然后通过RSA加密传输给服务器，要么由ECDHE算法进行密钥交换（ECDHE是现在最常用的）。你可能听过密钥交换算法（Key Exchange Algorithm），其实核心就是client和server双方协商出pre-master的算法，要么是RSA，要么是基于DH的算法，比如ECDHE。在 TLS 1.2 及以下，密钥交换算法可以是基于 RSA（直接加密 pre-master secret）或基于 Diffie-Hellman（如 ECDHE）的方式。在 TLS 1.3 及之后，密钥交换主要采用 ECDHE 等 DH 变种，并结合 HKDF 进行密钥派生。

#### 密钥交换算法-RSA（已废弃）
让我们首先来了解一下已经废弃的RSA交换方法。简单来说就是，客户端服务器生成一个随机数pre-master secret，然后用网站公钥对这个secret进行加密并传输给网站。网站收到数据后，用私钥对pre-master secret进行解密。这样一来，双方都拥有了Client Random，Server Random和pre-master secret，接下来便可以利用PRF函数进行分层的密钥生成。

这个算法的问题在于服务器的私钥参与了pre-master的传输过程。如果服务器的私钥泄露，pre-master secret就可以被破解，那么之前的连接就都泄露了，因为Client Random和Server Random都是在网络上明文传输的。因此，使用RSA作为密钥交换算法会使得连接不具备前向安全性。

#### 密钥交换算法-ECDHE
在ECDHE算法中，pre-master secret是由Client和Server共同生成的，而不是由Client生成完毕后发给Server。浏览器和网站双方交换椭圆参数来计算pre-secret master。每一次生成都是使用随机数，具有前向安全性。交互过程如下：

ECDHE（椭圆曲线Diffie-Hellman临时密钥交换）是一种基于椭圆曲线的安全密钥交换协议，它允许两个通信方安全地协商共享密钥，而不会直接暴露该密钥。其基本过程如下：

1. **参数选择**：
   - 选取椭圆曲线参数 (E) 和基点 (G)（公有参数）。

2. **密钥对生成**：
   - Client随机生成一个私钥(a)，计算公钥 ( A = aG ) 并发送给Server。
   - Server随机生成一个私钥(b)，计算公钥 ( B = bG ) 并发送给Client。

3. **共享密钥计算**：
   - Client收到Server的公钥 (B) 后计算 ( S = aB = a(bG) )。
   - Server收到Client的公钥 (A) 后计算 ( S = bA = b(aG) )。

   由于椭圆曲线的数学性质，双方计算出的 (S) 值相同，即共享的pre-master secret密钥。

4. **密钥派生**：
   - 双方可使用 ( S ) 作为输入，通过密钥派生函数（KDF）生成最终会话密钥。

好了，以上就是和https相关的基本知识了。在后续的文章里，我们会使用Wireshark进行实际的抓包，并分析tls/ssl握手中的每一个包的含义。

---

**注**：本文参考了以下资料，如果想对https扫盲，就很值得一读：

- [https原理--RSA密钥协商算法](https://www.cnblogs.com/zipxzf/articles/14336313.html)
- [https原理--ECDHE密钥协商算法](https://www.cnblogs.com/zipxzf/articles/14346467.html)
- [TLS/SSL 协议详解 (30) SSL中的RSA、DHE、ECDHE、ECDH流程与区别](https://blog.csdn.net/mrpre/article/details/78025940)
- [刨根问底系列之https详细握手过程](https://juejin.cn/post/6847902219745181709)

当然了，还有伟大的ChatGPT和DeepSeek同学。